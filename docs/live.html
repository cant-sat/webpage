<body>

    <input type="text" name="Url" id="url" value="ws://localhost:12345">
    <input type="button" onclick="connect()" value="Connect" id="connect">
    <br>

    <input type="text" id="table" value="temperature" disabled="true">
    <input type="button" onclick="showTable(document.getElementById('table').value)" value="show" id="show" disabled="true">

    <br>
    <canvas id="graph"></canvas>
   
</body>

<script src="js/load.js"></script>
<script src="js/chart.js"></script>


<script>
    var tables = null

    var socket = null

    var data = {labels: [0], datasets: []}
    var options = {scales: {
        y: {
            beginAtZero: true
        }
    }}
    var config = {type: "line",
        data: data,
        options : options}

    var graph = new Chart(document.getElementById("graph"), config)
    var currentGraphs = []

    function connect() {
        currentGraphs = []
        updateGraph()
        tables = new Map()
        // disables the connect buttons
        document.getElementById("url").disabled = true
        document.getElementById("connect").disabled = true

        const url = document.getElementById("url").value

        socket = new WebSocket(url)

        socket.addEventListener("close", function (event) {
            console.log("closed")

            // enables the connect buttons
            document.getElementById("url").disabled = false
            document.getElementById("connect").disabled = false

            document.getElementById("table").disabled = true
            document.getElementById("show").disabled = true
        })

        socket.addEventListener("message", function (event) {
            console.log(event.data)

            var newEntrie = JSON.parse(event.data)

            // you cant have an empty or not 
            if(typeof newEntrie.table != typeof "string" || newEntrie.table == undefined || newEntrie.table == null){
                throw "error: table name error"
            }

            //if it is currently sending the already existing tables
            if (newEntrie.value == undefined && newEntrie.values != null && newEntrie.values != undefined) {
                if(typeof newEntrie.values[0] != typeof 1){
                    throw "error: only number tables are accepted"
                }
                console.log("created table " + newEntrie.table)
                tables.set(newEntrie.table, newEntrie.values)
            } 
            // if the thing being sent is real life data
            else if (newEntrie.value != undefined && newEntrie.value != null && newEntrie.values == undefined) {
                if(typeof newEntrie.value != typeof 1){
                    throw "error: only numbers are accepted"
                    return
                }
                
                if(tables.has(newEntrie.table)){
                    // adds the new entrie to the table if it exists
                    console.log("added entrie to table: " + newEntrie.table)
                    tables.get(newEntrie.table).push(newEntrie.value)
                }
                else{
                    // creates the table if it exists
                    console.log("created new table: " + newEntrie.table)
                    tables.set(newEntrie.table, [newEntrie.value])
                }

                updateGraph()
            }
            else{
                throw "error, bad message"
            }

            
        })

        socket.addEventListener("open", function () {
            document.getElementById("table").disabled = false
            document.getElementById("show").disabled = false

            console.log("Succesfully joined")
        })
    }

    function showTable(tableName){
        const visualize = tables.get(tableName)
        if (visualize != undefined && visualize != null && typeof visualize == typeof []) {

            // if they try to show the same table values twice throws error
            if(currentGraphs.includes(tableName)){
                throw "error: cant visualize same graph twice"
            }

            // adds the new table to visualize to the current graphs
            currentGraphs.push(tableName)

            //updates the graphs
            updateGraph()
        }
        else  {
            throw "error: table is empty or not array"
        }
    }

    function updateGraph(){
        // if there are no current graphs just return
        
            var longest = 0

            newData = []

            // loops through all the graph names it wants to visualize
            currentGraphs.forEach(element => {
                console.log(element)
                // adds the datas from the table that has the name with element to the new data
                newData.push({label: element, data: tables.get(element), tension : 0, borderColor: "rgb("+Math.floor((Math.random() * 255))+", "+Math.floor((Math.random() * 255))+", "+Math.floor((Math.random() * 255))+")", fill: true})

                // finds the longest values
                if(tables.get(element).length > longest){
                    longest = tables.get(element).length
                }
            });

            data.datasets = newData

            res = makeLabels(longest)
            console.log(res)

            data.labels = res
        

        //updates the graph with no animation
        graph.update("none")
    }

    //makes the labels for a size of "size"
    function makeLabels(size){
        ret = []
        for (let index = 0; index < size; index++) {
            ret.push(index);   
        }
        return ret
    }
  </script>